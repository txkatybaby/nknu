{
  "name": "Nknu",
  "tagline": "Inhavenoidea",
  "body": "\r\n#include <dlfcn.h>\t\t/* For dynamic loading */\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <pthread.h>\r\n\r\n\r\n/* #include \"OMX_RegLib.h\" */\r\n#include \"OMX_Component.h\"\r\n#include \"OMX_Core.h\"\r\n#include \"OMX_ComponentRegistry.h\"\r\n\r\n#include \"timm_osal_types.h\"\r\n#include \"timm_osal_error.h\"\r\n#include \"timm_osal_trace.h\"\r\n#include \"timm_osal_mutex.h\"\r\n\r\n#ifdef CHECK_SECURE_STATE\r\n#include <sys/ioctl.h>\r\n#include <errno.h>\r\n#include <fcntl.h>\r\n#endif\r\n\r\n/** size for the array of allocated components.  Sets the maximum\r\n * number of components that can be allocated at once */\r\n#define MAXCOMP (50)\r\n#define MAXNAMESIZE (128)\r\n#define EMPTY_STRING \"\\0\"\r\n\r\n/** Determine the number of elements in an array */\r\n#define COUNTOF(x) (sizeof(x)/sizeof(x[0]))\r\n\r\n/** Array to hold the DLL pointers for each allocated component */\r\nstatic void *pModules[MAXCOMP] = { 0 };\r\n\r\n/** Array to hold the component handles for each allocated component */\r\nstatic void *pComponents[COUNTOF(pModules)] = { 0 };\r\n\r\n/* count for call OMX_Init() */\r\nint count = 0;\r\npthread_mutex_t mutex;\r\nTIMM_OSAL_PTR pCoreInitMutex = NULL;\r\n\r\nint tableCount = 0;\r\nComponentTable componentTable[MAX_TABLE_SIZE];\r\nchar *sRoleArray[60][20];\r\nchar compName[60][200];\r\n\r\n\r\nchar *tComponentName[MAXCOMP][MAX_ROLES] = {\r\n    /*video and image components */\r\n    {\"OMX.TI.DUCATI1.VIDEO.DECODER\", \"video_decoder.mpeg4\",\r\n        \"video_decoder.avc\",\r\n        \"video_decoder.h263\",\r\n        \"video_decoder.wmv\",\r\n        \"video_decoder.vp6\",\r\n        \"video_decoder.vp7\", NULL},\r\n    {\"OMX.TI.DUCATI1.VIDEO.DECODER.secure\", \"video_decoder.mpeg4\",\r\n        \"video_decoder.avc\",\r\n        \"video_decoder.h263\", NULL},\r\n    {\"OMX.TI.DUCATI1.VIDEO.H264D\",  \"video_decoder.avc\", NULL},\r\n    {\"OMX.TI.DUCATI1.VIDEO.H264E\",  \"video_encoder.avc\", NULL},\r\n    {\"OMX.TI.DUCATI1.VIDEO.MPEG4D\", \"video_decoder.mpeg4\", NULL},\r\n    {\"OMX.TI.DUCATI1.VIDEO.MPEG4E\", \"video_encoder.mpeg4\",\r\n                                    \"video_encoder.h263\",NULL},\r\n    {\"OMX.TI.DUCATI1.VIDEO.VP6D\",   \"video_decoder.vp6\", NULL},\r\n    {\"OMX.TI.DUCATI1.VIDEO.VP7D\",   \"video_decoder.vp7\", NULL},\r\n    {\"OMX.TI.DUCATI1.IMAGE.JPEGD\",  \"jpeg_decoder.jpeg\", NULL},\r\n    {\"OMX.TI.DUCATI1.VIDEO.CAMERA\",  \"camera.omx\", NULL},\r\n    /* terminate the table */\r\n    {NULL, NULL},\r\n};\r\n\r\n//AD\r\nextern OMX_ERRORTYPE OMX_ComponentInit(OMX_HANDLETYPE hComponent);\r\n\r\n#define CORE_assert  CORE_paramCheck\r\n#define CORE_require CORE_paramCheck\r\n#define CORE_ensure  CORE_paramCheck\r\n\r\n#define CORE_paramCheck(C, V, S) do {\\\r\n    if (!(C)) { eError = V;\\\r\n    TIMM_OSAL_Error(\"failed check: \" #C);\\\r\n    TIMM_OSAL_Error(\" - returning error: \" #V);\\\r\n    if(S) TIMM_OSAL_Error(\" - %s\", S);\\\r\n    goto EXIT; }\\\r\n    } while(0)\r\n\r\n/******************************Public*Routine******************************\\\r\n* OMX_Init()\r\n*\r\n* Description:This method will initialize the OMX Core.  It is the\r\n* responsibility of the application to call OMX_Init to ensure the proper\r\n* set up of core resources.\r\n*\r\n* Returns:    OMX_NOERROR          Successful\r\n*\r\n* Note\r\n*\r\n\\**************************************************************************/\r\nOMX_ERRORTYPE OMX_Init()\r\n{\r\n\tOMX_ERRORTYPE eError = OMX_ErrorNone;\r\n\tTIMM_OSAL_ERRORTYPE eOsalError = TIMM_OSAL_ERR_NONE;\r\n\r\n\teOsalError = TIMM_OSAL_MutexObtain(pCoreInitMutex, TIMM_OSAL_SUSPEND);\r\n\tCORE_assert(eOsalError == TIMM_OSAL_ERR_NONE,\r\n\t    OMX_ErrorInsufficientResources, \"Mutex lock failed\");\r\n\r\n\tcount++;\r\n\r\n\tif (count == 1)\r\n\t{\r\n\t\tpthread_mutex_init(&mutex, NULL);\r\n\t\teError = OMX_BuildComponentTable();\r\n\t}\r\n\r\n\teOsalError = TIMM_OSAL_MutexRelease(pCoreInitMutex);\r\n\tCORE_assert(eOsalError == TIMM_OSAL_ERR_NONE,\r\n\t    OMX_ErrorInsufficientResources, \"Mutex release failed\");\r\n      EXIT:\r\n\treturn eError;\r\n}\r\n\r\n/******************************Public*Routine******************************\\\r\n* OMX_GetHandle\r\n*\r\n* Description: This method will create the handle of the COMPONENTTYPE\r\n* If the component is currently loaded, this method will reutrn the\r\n* hadle of existingcomponent or create a new instance of the component.\r\n* It will call the OMX_ComponentInit function and then the setcallback\r\n* method to initialize the callback functions\r\n* Parameters:\r\n* @param[out] pHandle            Handle of the loaded components\r\n* @param[in] cComponentName     Name of the component to load\r\n* @param[in] pAppData           Used to identify the callbacks of component\r\n* @param[in] pCallBacks         Application callbacks\r\n*\r\n* @retval OMX_ErrorUndefined\r\n* @retval OMX_ErrorInvalidComponentName\r\n* @retval OMX_ErrorInvalidComponent\r\n* @retval OMX_ErrorInsufficientResources\r\n* @retval OMX_NOERROR                      Successful\r\n*\r\n* Note\r\n*\r\n\\**************************************************************************/\r\n\r\nOMX_ERRORTYPE OMX_GetHandle(OMX_HANDLETYPE * pHandle,\r\n    OMX_STRING cComponentName, OMX_PTR pAppData,\r\n    OMX_CALLBACKTYPE * pCallBacks)\r\n{\r\n\tstatic const char prefix[] = \"lib\";\r\n\tstatic const char postfix[] = \".so\";\r\n\tOMX_ERRORTYPE(*pComponentInit) (OMX_HANDLETYPE *);\r\n\tOMX_ERRORTYPE eError = OMX_ErrorNone;\r\n\tOMX_COMPONENTTYPE *componentType;\r\n\tint i;\r\n\tchar buf[sizeof(prefix) + MAXNAMESIZE + sizeof(postfix)];\r\n\tconst char *pErr = dlerror();\r\n\tchar *dlError = NULL;\r\n#ifdef CHECK_SECURE_STATE\r\n        int secure_misc_drv_fd,ret;\r\n        OMX_U8 mode, enable=1;\r\n#endif\r\n\tif (pthread_mutex_lock(&mutex) != 0)\r\n\t{\r\n\t\tTIMM_OSAL_Error(\"Core: Error in Mutex lock\");\r\n\t}\r\n\r\n\tCORE_require(NULL != cComponentName, OMX_ErrorBadParameter, NULL);\r\n\tCORE_require(NULL != pHandle, OMX_ErrorBadParameter, NULL);\r\n\tCORE_require(NULL != pCallBacks, OMX_ErrorBadParameter, NULL);\r\n\tCORE_require(count > 0, OMX_ErrorUndefined,\r\n\t    \"OMX_GetHandle called without calling OMX_Init first\");\r\n\r\n\t/* Verify that the name is not too long and could cause a crash.  Notice\r\n\t * that the comparison is a greater than or equals.  This is to make\r\n\t * sure that there is room for the terminating NULL at the end of the\r\n\t * name. */\r\n\tCORE_require(strlen(cComponentName) < MAXNAMESIZE,\r\n\t    OMX_ErrorInvalidComponentName, NULL);\r\n\r\n\t/* Locate the first empty slot for a component.  If no slots\r\n\t * are available, error out */\r\n\tfor (i = 0; i < COUNTOF(pModules); i++)\r\n\t{\r\n\t\tif (pModules[i] == NULL)\r\n\t\t\tbreak;\r\n\t}\r\n\tCORE_assert(i != COUNTOF(pModules), OMX_ErrorInsufficientResources,\r\n\t    NULL);\r\n\r\n\t/* load the component and check for an error.  If filename is not an\r\n\t * absolute path (i.e., it does not  begin with a \"/\"), then the\r\n\t * file is searched for in the following locations:\r\n\t *\r\n\t *     The LD_LIBRARY_PATH environment variable locations\r\n\t *     The library cache, /etc/ld.so.cache.\r\n\t *     /lib\r\n\t *     /usr/lib\r\n\t *\r\n\t * If there is an error, we can't go on, so set the error code and exit */\r\n\tstrcpy(buf, prefix);\t/* the lengths are defined herein or have been */\r\n\tstrcat(buf, cComponentName);\t/* checked already, so strcpy and strcat are  */\r\n\tstrcat(buf, postfix);\t/* are safe to use in this context. */\r\n\r\n#ifdef CHECK_SECURE_STATE\r\n        //Dont return errors from misc driver to the user if any.\r\n        //Since this affects all usecases, secure and non-secure.\r\n        //Do log the errors though.\r\n        secure_misc_drv_fd = open(\"/dev/rproc_user\", O_SYNC | O_RDONLY);\r\n\tif (secure_misc_drv_fd < 0)\r\n\t{\r\n\t\tTIMM_OSAL_Error(\"Can't open misc driver device 0x%x\\n\", errno);\r\n\t}\r\n\r\n\tret = read(secure_misc_drv_fd, &mode, sizeof(mode));\r\n\tif (ret < 0)\r\n\t{\r\n\t\tTIMM_OSAL_Error(\"Can't read from the misc driver\");\r\n\t}\r\n        if(mode == enable && strstr(cComponentName,\"secure\") == NULL)\r\n\t{\r\n\t\tTIMM_OSAL_Error(\"non-secure component not supported in secure mode\");\r\n\t\teError = OMX_ErrorComponentNotFound;\r\n\t}\r\n\tret = close(secure_misc_drv_fd);\r\n\tif (ret < 0)\r\n\t{\r\n\t\tTIMM_OSAL_Error(\"Can't close the misc driver\");\r\n\t}\r\n        //Dont allow non-secure usecases if we are in secure state.\r\n        //Else some of the memory regions will be unexpected firewalled.\r\n        //This provides a clean exit in case we are in secure mode.\r\n        if(eError == OMX_ErrorComponentNotFound)\r\n        {\r\n                goto EXIT;\r\n        }\r\n***\r\n### Welcome to GitHub Pages.\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here [using GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/), select a template crafted by a designer, and publish. After your page is generated, you can check out the new `gh-pages` branch locally. If you’re using GitHub Desktop, simply sync your repository and you’ll see the new branch.\r\n\r\n### Designer Templates\r\nWe’ve crafted some handsome templates for you to use. Go ahead and click 'Continue to layouts' to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved.\r\n\r\n### Creating pages manually\r\nIf you prefer to not use the automatic generator, push a branch named `gh-pages` to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.\r\n\r\n### Authors and Contributors\r\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor’s GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out our [documentation](https://help.github.com/pages) or [contact support](https://github.com/contact) and we’ll help you sort it out.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}